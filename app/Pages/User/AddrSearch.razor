@using app.Models
@inject NavigationManager Nav
@inject IJSRuntime JS
<style>
    .form-control:focus,
    .form-control:active {
        outline: none !important;
        box-shadow: none !important;
    }
</style>

<input class="form-control" id="addressInput" value="@(searchText?.Split(',')[0])" @oninput="OnInputChanged"
    @onfocus="OnFocus" placeholder="@Placeholder" autocomplete="off" />

@if (isLoading)
{
    <div class="flex justify-content-center mt-2 mx-2 border-0">
        <span class="spinner-border" role="status" aria-hidden="true"
            style="width:1.7rem; height:1.7rem; border-width:.28rem;"></span>
    </div>
}

@if (showSuggestions && predictions != null && predictions.Count > 0)
{
    <ul class="autocomplete-dropdown">
        @foreach (var prediction in predictions)
        {
            <li @onclick="@(() => SelectPrediction(prediction))">
                <div class="suggestion-item">
                    <strong>@prediction.MainText</strong>
                    <br />
                    <small class="text-muted">@prediction.SecondaryText</small>
                </div>
            </li>
        }
    </ul>
}

@if (showSuggestions && predictions != null && predictions.Count == 0 && !isLoading && searchText.Length >=
MinCharacters)
{
    <ul class="autocomplete-dropdown">
        <li class="no-results">No addresses found</li>
    </ul>
}

<button class="btn btn-primary ms-1" type="button" @onclick="OnClick" @ondblclick="OnDbClick">
    @* <i class="bi bi-search fs-6"></i> *@
    <span class="d-none d-lg-inline">Search</span>
</button>

@code {
    [Parameter]
    public string Label { get; set; } = "Address";

    [Parameter]
    public string Placeholder { get; set; } = "Your address or postal code";

    [Parameter]
    public string CountryCode { get; set; } = "ca"; // ISO 3166-1 Alpha-2 country code

    [Parameter]
    public EventCallback<PlaceDetails> OnAddressSelected { get; set; }

    [Parameter]
    public EventCallback<MouseEventArgs> OnClick { get; set; }

    [Parameter]
    public EventCallback<MouseEventArgs> OnDbClick { get; set; }

    [Parameter]
    public int MinCharacters { get; set; } = 3;

    [Parameter]
    public int DebounceMs { get; set; } = 300;

    [Parameter]
    public string AddrValue
    {
        get => searchText;
        set
        {
            searchText = value;
        }

    }


    [Parameter]
    public EventCallback<string> AddrValueChanged { get; set; }

    private string searchText = string.Empty;
    private List<PlacePrediction> predictions = new List<PlacePrediction>();
    private bool showSuggestions = false;
    private bool isLoading = false;
    private string errorMessage = string.Empty;
    private CancellationTokenSource? cancellationTokenSource;

    private async Task OnInputChanged(ChangeEventArgs e)
    {
        searchText = e.Value?.ToString() ?? string.Empty;
        errorMessage = string.Empty;

        cancellationTokenSource?.Cancel();

        if (string.IsNullOrWhiteSpace(searchText) || searchText.Length < MinCharacters)
        {
            predictions.Clear();
            showSuggestions = false;
            isLoading = false;
            StateHasChanged();
            return;
        }

        isLoading = true;
        showSuggestions = true;
        StateHasChanged();

        cancellationTokenSource = new CancellationTokenSource();

        try
        {
            await Task.Delay(DebounceMs, cancellationTokenSource.Token);
            await GetPredictions(searchText, cancellationTokenSource.Token);
        }
        catch (TaskCanceledException)
        {
            // Ignore cancellation
        }

        if (AddrValueChanged.HasDelegate) // Send value update to the parent page
        {
            await AddrValueChanged.InvokeAsync(searchText);
        }
        AddrValue = searchText;
    }

    private async Task GetPredictions(string input, CancellationToken cancellationToken)
    {
        try
        {
            var result = await JS.InvokeAsync<List<PlacePrediction>>(
            "placesAutocomplete.getPlacePredictions",
            cancellationToken,
            input,
            CountryCode
            );

            predictions = result ?? new List<PlacePrediction>();
        }
        catch (Exception ex)
        {
            errorMessage = "Error fetching address suggestions";
            Console.WriteLine($"Error: {ex.Message}");
            predictions.Clear();
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    private async Task SelectPrediction(PlacePrediction prediction)
    {
        searchText = prediction.Description;
        showSuggestions = false;
        predictions.Clear();
        isLoading = true;
        errorMessage = string.Empty;
        StateHasChanged();
        AddrValue = searchText;

        try
        {
            // Trigger parent search immediately after selection
            if (AddrValueChanged.HasDelegate)
            {
                await AddrValueChanged.InvokeAsync(searchText);
            }

            if (OnClick.HasDelegate)
            {
                await OnClick.InvokeAsync(new MouseEventArgs());
            }
        }
        catch (Exception ex)
        {
            errorMessage = "Error fetching address details";
            Console.WriteLine($"Error while selecting prediction: {ex.Message}");
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    private void OnFocus()
    {
        if (predictions.Count > 0)
        {
            showSuggestions = true;
        }
    }

    public void Dispose()
    {
        cancellationTokenSource?.Cancel();
        cancellationTokenSource?.Dispose();
    }




}